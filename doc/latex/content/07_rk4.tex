\section{RK4-Algorithmus}
Das \textbf{Runge-Kutta 4. Ordnung (RK4)}-Verfahren löst eine gewöhnliche Differentialgleichung (ODE) der Form:
\[
\frac{dy}{dt} = f(t, y)
\]
mit Anfangswert \( y(t_0) = y_0 \). Der Algorithmus verwendet vier Stützstellen pro Zeitschritt, um eine hohe Genauigkeit (\(\mathcal{O}(\Delta t^5)\) pro Schritt, \(\mathcal{O}(\Delta t^4)\) global) zu erreichen.

\subsection*{Schritte pro Iteration}
Für jeden Zeitschritt \(\Delta t\) werden folgende Koeffizienten berechnet:
\[
\begin{aligned}
k_1 &= f(t_n, y_n), \\
k_2 &= f\left(t_n + \frac{\Delta t}{2}, y_n + \frac{k_1 \Delta t}{2}\right), \\
k_3 &= f\left(t_n + \frac{\Delta t}{2}, y_n + \frac{k_2 \Delta t}{2}\right), \\
k_4 &= f(t_n + \Delta t, y_n + k_3 \Delta t).
\end{aligned}
\]
Die Lösung am nächsten Zeitpunkt \( t_{n+1} = t_n + \Delta t \) ist:
\[
y_{n+1} = y_n + \frac{\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4).
\]

\section*{C-Implementierung}
\begin{lstlisting}[language=C, caption={Generische RK4-Implementierung}, frame=tb, backgroundcolor=\color{gray!10}, commentstyle=\color{teal}]
#include <stdio.h>
#include <stdlib.h>

// Allgemeine RK4-Integration fuer dy/dt = f(t, y)
void rk4(
    double (*f)(double, double), // Funktion dy/dt = f(t, y)
    double t_start,              // Startzeit
    double t_end,                // Endzeit
    double dt,                   // Zeitschritt
    double y0,                   // Anfangswert y(t_start)
    double* t,                   // Zeit-Array (Output)
    double* y                    // Loesungs-Array (Output)
) {
    int steps = (int)((t_end - t_start) / dt) + 1;
    double k1, k2, k3, k4;
    int i;

    t[0] = t_start;
    y[0] = y0;

    for (i = 0; i < steps - 1; i++) {
        t[i+1] = t[i] + dt;
        k1 = f(t[i], y[i]);
        k2 = f(t[i] + 0.5 * dt, y[i] + 0.5 * k1 * dt);
        k3 = f(t[i] + 0.5 * dt, y[i] + 0.5 * k2 * dt);
        k4 = f(t[i] + dt, y[i] + k3 * dt);
        y[i+1] = y[i] + (k1 + 2*k2 + 2*k3 + k4) * dt / 6.0;
    }
}

// Beispiel-ODE: dy/dt = -y (Loesung: y(t) = y0 * exp(-t))
double example_ode(double t, double y) {
    return -y;
}

int main() {
    double t_start = 0.0, t_end = 5.0, dt = 0.1, y0 = 1.0;
    int steps = (int)((t_end - t_start) / dt) + 1;

    double* t = (double*)malloc(steps * sizeof(double));
    double* y = (double*)malloc(steps * sizeof(double));

    rk4(example_ode, t_start, t_end, dt, y0, t, y);

    // Ausgabe der Loesung
    for (int i = 0; i < steps; i++) {
        printf("t = %.2f, y = %.6f\n", t[i], y[i]);
    }

    free(t);
    free(y);
    return 0;
}
\end{lstlisting}

\section*{Eigenschaften}
\begin{itemize}
    \item \textbf{Fehlerordnung}: Lokal \(\mathcal{O}(\Delta t^5)\), global \(\mathcal{O}(\Delta t^4)\).
    \item \textbf{Anwendung}: Ideal für glatte ODEs 1. Ordnung (z. B. \( \frac{d\phi}{dt} = \omega(\phi) \)).
    \item \textbf{Vorteile}: Einfach zu implementieren, hohe Genauigkeit.
    \item \textbf{Nachteile}: Keine adaptive Schrittweite, ineffizient für steife Systeme.
\end{itemize}

\section*{Beispielausgabe}
Für \( dy/dt = -y \) mit \( y(0) = 1 \), \( \Delta t = 0.1 \):
\begin{verbatim}
t = 0.00, y = 1.000000
t = 0.10, y = 0.904837
t = 0.20, y = 0.818731
...
t = 5.00, y = 0.006738
\end{verbatim}
